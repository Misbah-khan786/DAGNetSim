  # def add_transactions(self, num_transactions):
    #     if len(self.tips) < 2:
    #         return
    #
    #     for i in range(num_transactions):
    #         # Select two tips as parents
    #         parents = random.sample(self.tips, 2)
    #
    #         # Check if either parent is already a parent of the other parent
    #         for j in range(len(parents)):
    #             if parents[j] in parents[1 - j].parent_txids:
    #                 parents.pop(j)
    #                 break
    #
    #         # Create new transaction with selected parents
    #         txid = str(len(self.transactions))
    #         parent_txids = [parent.txid for parent in parents]
    #         tx = Transaction(txid, parent_txids)
    #
    #         # Add new transaction to DAG
    #         self.transactions[txid] = tx
    #         self.tips.append(tx)
    #
    #         # Update parents' child lists
    #         for parent in parents:
    #             parent.children.append(tx)
    #
    #             if len(parent.children) == 1:
    #                 self.tips.append(parent)
    #             elif len(parent.children) == 2 and parent in self.tips:
    #                 self.tips = [tip for tip in self.tips if tip != parent]
    #
    #         # Remove old tips from tip list
    #         self.tips = [tip for tip in self.tips if tip not in parents]
    #
    #         print(f"Added transaction: {tx}")
    #         print(f"New tips: {[tip.txid for tip in self.tips]}")




    Last correct version of DAG

    class DAG:
    def __init__(self, poisson_rate):
        self.poisson_rate = poisson_rate
        self.transactions = {}
        self.genesis_transaction = Transaction("0", [])
        self.transactions[self.genesis_transaction.txid] = self.genesis_transaction
        self.tips = [self.genesis_transaction]
        self.graph = nx.DiGraph()
        self.batch_num = 1  # initialize batch number
        self.batches = []  # list of batches

    def add_transactions(self, num_transactions):
        if not self.tips:
            return

        # Get the list of previous tips
        prev_tips = self.tips[:]

        new_transactions = []

        for i in range(num_transactions):
            # Select two tips from the previous tips list
            if len(prev_tips) < 2:
                tips = prev_tips + [prev_tips[0]]
            else:
                tips = random.sample(prev_tips, 2)

            # Create new transaction with selected parents
            txid = str(len(self.transactions))
            parent_txids = [parent.txid for parent in tips]
            tx = Transaction(txid, parent_txids)

            # Add new transaction to DAG and new_transactions list
            self.transactions[txid] = tx
            new_transactions.append(tx)

            # Update parents' child lists
            for parent in tips:
                parent.children.append(tx)
                if len(parent.children) == 1:
                    self.tips.append(parent)

            # Add edge to graph
            self.graph.add_edge(*parent_txids, txid=txid)

            # Print transaction info with batch number
            print(f"Batch {self.batch_num}: Added {tx} to DAG.")

        # Update tips to be the new_transactions list
        self.tips = new_transactions

        # Append new transactions to the list of batches
        self.batches.append(new_transactions)

        # Increment batch number
        self.batch_num += 1







        #########################################
            def add_transactions(self, num_transactions):
        prev_tips = [tx for tx in self.tips + list(self.transactions.values()) if not tx.children]
        if not prev_tips:
            return
        new_transactions = []
        for i in range(num_transactions):
            # Select two tips from the previous tips list
            if len(prev_tips) < 2:
                tips = prev_tips + [prev_tips[0]]
                print("tips", tips)
            else:
                tips = random.sample(prev_tips, 2)

            # Create new transaction with selected parents
            txid = str(len(self.transactions))
            #print("txid in add transaction method", txid)
            parent_txids = [parent.txid for parent in tips]
            tx = Transaction(txid, parent_txids)

            # Add new transaction to DAG and new_transactions list
            self.transactions[txid] = tx
            new_transactions.append(tx)

            # Calculate own weight
            tx.own_weight = 1

            # Calculate accumulative weight
            # tx.accumulative_weight = tx.own_weight + sum(child.accumulative_weight for child in tx.children)
            # Calculate accumulative weight
            visited = set()
            queue = deque([tx])
            while queue:
                curr_tx = queue.popleft()
                visited.add(curr_tx)
                curr_tx.accumulative_weight = curr_tx.own_weight + sum(
                    child.accumulative_weight for child in curr_tx.children)
                for child in curr_tx.children:
                    if child not in visited:
                        queue.append(child)

            # Calculate branch weight
            parents = [self.transactions[parent_txid] for parent_txid in tx.parent_txids]
            tx.branch_weight = sum(parent.accumulative_weight for parent in parents)

            # Update parents' child lists
            for parent in tips:
                parent.children.append(tx)
                if len(parent.children) == 1:
                    self.tips.append(parent)

            # Add edge to graph
            self.graph.add_edge(*parent_txids, txid=txid)

            # Print transaction info with batch number
            print(f"Batch {self.batch_num}: Added {tx} to DAG.")
            # Print updated accumulative weight for each transaction
            # for transaction in self.transactions.values():
            #     print(f"Transaction {transaction.txid}: Updated Accumulative weight: {transaction.accumulative_weight}")
            #print(f"Batch {self.batch_num}: Added {tx} to DAG. Own weight: {tx.own_weight}, " \
            #       f"Accumulative weight: {tx.accumulative_weight}, Branch weight: {tx.branch_weight}")

        # Update tips to be the new_transactions list plus any tips that were not parents
        self.tips = [tx for tx in self.tips + list(self.transactions.values()) if not tx.children]
        print("all tips",self.tips)

        # Append new transactions to the list of batches
        self.batches.append(new_transactions)

        # Increment batch number
        self.batch_num += 1
        #print("previous tips", prev_tips)
        # Print updated weights for each transaction at the end of the batch
        print(f"End of Batch {self.batch_num - 1}: Updated weights for each transaction:")
        for transaction in self.transactions.values():
            print(f"Transaction {transaction.txid}: Own weight: {transaction.own_weight}, " \
                  f"Accumulative weight: {transaction.accumulative_weight}, " \
                  f"Branch weight: {transaction.branch_weight}")
################################################################################################################
    def draw(self):
        # Create a directed graph object
        G = nx.DiGraph()
        # Set node colors
        node_colors = []
        node_labels = {}  # Store node labels
        for tx in self.transactions.values():
            #print("batch numer", self.num_batches)
            if tx.txid == '1':
                node_colors.append('orange')  # orange for tips
            elif tx.txid == '0' and self.current_batch == 0:
                node_colors.append('grey')  # gray for first transaction
            elif tx in self.tips:
                node_colors.append('grey')  # gray for tips
            else:
                node_colors.append('blue')  # blue for other nodes

                # Add accumulative weight and transaction ID as a label
                label = f"ID: {tx.txid}\nAW: {tx.accumulative_weight}"  # Construct the label with ID and accumulative weight
                node_labels[tx.txid] = label

        # Get node positions and heights
        pos = {}
        heights = {}
        for tx in self.transactions.values():
            if tx.txid == '0':
                pos[tx.txid] = (0, 0)
                heights[tx.txid] = 0
            else:
                max_height = max(heights[parent_txid] for parent_txid in tx.parent_txids)
                pos[tx.txid] = (max_height + 1, len(heights))
                heights[tx.txid] = max_height + 1

        # Add edges to the graph
        for tx in self.transactions.values():
            for parent_txid in tx.parent_txids:
                G.add_edge(tx.txid, parent_txid)

        # Draw the graph
        plt.figure(figsize=(10, 5))
        nx.draw(G, pos=pos, with_labels=True, node_color=node_colors, node_size=1000, node_shape='s')
        #plt.axis('equal')
        plt.ylim(-1, len(heights))
        plt.xlim(-1, max(heights.values()) + 1)
        plt.show()


       ################################################################Working add transaction method with random walk#############################
           def add_transactions(self, num_transactions):
        prev_tips = [tx for tx in self.tips + list(self.transactions.values()) if not tx.children]
        if not prev_tips:
            return
        # Instantiate the random walker
        random_walker = RandomWalker(W=3, N=2, alpha=0.01)
        new_transactions = []
        batch_tips = [random_walker.walk(self) for _ in range(num_transactions)]
        # for i in range(num_transactions):
        #     if len(set(prev_tips)) < 2:
        #         tips = [prev_tips[0], prev_tips[0]]
        #     else:
        #         #tips = random.sample(list(set(prev_tips)), 2)
        #         # Instead of randomly choosing the tips, use the random walker to select the tips
        #         # tips = random_walker.walk(self)
        #         # # If the random walker returned duplicate tips, handle this case appropriately
        #         # # For example, you might choose to select an additional tip randomly
        #         # if len(set(tips)) < 2:
        #         #     additional_tip = random.choice([tx for tx in prev_tips if tx not in tips])
        #         #     tips.append(additional_tip)
        #
        #         # Prepare tips for all transactions in the batch
        #         batch_tips = [random_walker.walk(self) for _ in range(num_transactions)]
        for i, tips in enumerate(batch_tips):
            txid = str(len(self.transactions))
            parent_txids = list(set(parent.txid for parent in tips))
            tx = Transaction(txid, parent_txids)
            tx.parent_transactions = tips  # Update parent_transactions
            self.transactions[txid] = tx
            new_transactions.append(tx)

            # Only after all transactions have been prepared, add them to the DAG
            for tx in new_transactions:
                tips = tx.parent_transactions

                for parent in set(tips):  # Use a set to remove duplicates
                    parent.children.append(tx)

                    if len(parent.children) == 1:
                        self.tips.append(parent)

                for parent in tx.parent_txids:
                    self.graph.add_edge(parent, tx.txid)
                print(f"Batch {self.batch_num}: Added {tx} to DAG.")


            # for parent in set(tips):  # Use a set to remove duplicates
            #     parent.children.append(tx)
            #
            #     if len(parent.children) == 1:
            #         self.tips.append(parent)
            #
            # for parent in parent_txids:
            #     self.graph.add_edge(parent, txid)
            # print(f"Batch {self.batch_num}: Added {tx} to DAG.")

        self.tips = [tx for tx in self.tips + list(self.transactions.values()) if not tx.children]
        self.batches.append(new_transactions)
        self.batch_num += 1

        # Update accumulative weights
        self.update_weights_topological_order()
        # Update branch weights
        for tx in new_transactions:
            tx.update_branch_weight()
#################################################################################################################
    def add_transactions(self, num_transactions):
        new_transactions = []
        prev_tips = [tx for tx in self.tips + list(self.transactions.values()) if not tx.children]
        print("Previous Tips", prev_tips)
        if not prev_tips:
            return
        # Instantiate the random walker
        random_walker = RandomWalker(W=3, N=2, alpha=0.01)
        new_transactions = []

        # Select tips before the loop

        if len(set(prev_tips)) < 2:
            batch_tips = [prev_tips[0], prev_tips[0]]
            print("batch tips at start", batch_tips)
        else:
            batch_tips = random_walker.walk(self)
            if len(set(batch_tips)) < 2:
                additional_tip = random.choice([tx for tx in prev_tips if tx not in batch_tips])
                batch_tips.append(additional_tip)
        # Use the same tips for all transactions within the batch
        for i in range(num_transactions):
            tips = batch_tips
            print("In Loop Batch Tips",tips)

            txid = str(len(self.transactions))
            parent_txids = list(set(parent.txid for parent in tips))
            tx = Transaction(txid, parent_txids)
            tx.parent_transactions = tips  # Update parent_transactions
            self.transactions[txid] = tx
            new_transactions.append(tx)

            for parent in set(tips):  # Use a set to remove duplicates
                parent.children.append(tx)

                if len(parent.children) == 1:
                    self.tips.append(parent)

            for parent in parent_txids:
                self.graph.add_edge(parent, txid)
            print(f"Batch {self.batch_num}: Added {tx} to DAG.")

        # update tips at the end of the batch
        self.tips = [tx for tx in self.tips + list(self.transactions.values()) if not tx.children]
        self.batches.append(new_transactions)
        self.batch_num += 1

        # Update accumulative weights
        self.update_weights_topological_order()
        # Update branch weights
        for tx in new_transactions:
            tx.update_branch_weight()
   ############################################################################################################
       def add_transactions(self, num_transactions):
        new_transactions = []
        # Capture the state of tips at the start of the batch
        prev_tips = [tx for tx in self.tips + list(self.transactions.values()) if not tx.children]
        print("Previous Tips", prev_tips)
        if not prev_tips:
            return

        # Instantiate the random walker
        random_walker = RandomWalker(W=3, N=2, alpha=1.0)
        new_transactions = []

        for i in range(num_transactions):
            # Select tips for each transaction
            if len(set(prev_tips)) < 2:
                tips = [prev_tips[0], prev_tips[0]]
                print("batch tips at start", tips)
            else:
                tips = random_walker.walk(self, prev_tips)
                # if len(set(tips)) < 2:
                #     additional_tip = random.choice([tx for tx in prev_tips if tx not in tips])
                #     tips.append(additional_tip)
            print("In Loop Batch Tips", tips)

            txid = str(len(self.transactions))
            parent_txids = list(set(parent.txid for parent in tips))
            tx = Transaction(txid, parent_txids)
            tx.parent_transactions = tips  # Update parent_transactions
            self.transactions[txid] = tx
            new_transactions.append(tx)

            for parent in set(tips):  # Use a set to remove duplicates
                parent.children.append(tx)

                # if len(parent.children) == 1:
                #     self.tips.append(parent)
            for parent in parent_txids:
                self.graph.add_edge(parent, txid)
            print(f"Batch {self.batch_num}: Added {tx} to DAG.")

        # update tips at the end of the batch
        self.tips = [tx for tx in self.tips + list(self.transactions.values()) if not tx.children]
        print("tips at the end of current batch",self.tips)
        self.batches.append(new_transactions)
        self.batch_num += 1

        # Update accumulative weights
        self.update_weights_topological_order()
        # Update branch weights
        for tx in new_transactions:
            tx.update_branch_weight()
   ###################################################################################################################
    def draw(self):
        # Create a directed graph object
        G = nx.DiGraph()

        # Set node colors and labels
        node_colors = {}
        node_labels = {}  # Store node labels
        depth_map = {}
        max_depth = 0

        # Handle the genesis transaction separately
        genesis_tx = self.transactions['1']
        # print("Gensis transaction",genesis_tx)
        node_labels[genesis_tx.txid] = f"ID: {genesis_tx.txid}\nAW: {genesis_tx.accumulative_weight}"
        node_colors[genesis_tx.txid] = 'orange'  # Orange for genesis transaction
        depth_map[genesis_tx.txid] = 1

        # # Handle the transaction with txid == '1' separately
        if '1' in self.transactions and self.current_batch == 0:
            tx_1 = self.transactions['0']
            node_labels[tx_1.txid] = f"ID: {tx_1.txid}\nAW: {tx_1.accumulative_weight}"
            node_colors[tx_1.txid] = 'grey'  # Orange for transaction with txid == '1'
            depth_map[tx_1.txid] = 0
        elif '1' in self.transactions and self.current_batch != 0 and '1' not in self.tips:
            tx_1 = self.transactions['0']
            node_labels[tx_1.txid] = f"ID: {tx_1.txid}\nAW: {tx_1.accumulative_weight}"
            node_colors[tx_1.txid] = 'blue'  # Orange for transaction with txid == '1'
            depth_map[tx_1.txid] = 0
        elif '1' in self.transactions and self.current_batch != 0 and '1' in self.tips:
            tx_1 = self.transactions['0']
            node_labels[tx_1.txid] = f"ID: {tx_1.txid}\nAW: {tx_1.accumulative_weight}"
            node_colors[tx_1.txid] = 'grey'  # Orange for transaction with txid == '1'
            depth_map[tx_1.txid] = 0
        else:
            tx_1 = self.transactions['0']
            node_labels[tx_1.txid] = f"ID: {tx_1.txid}\nAW: {tx_1.accumulative_weight}"
            node_colors[tx_1.txid] = 'blue'  # Orange for transaction with txid == '1'
            depth_map[tx_1.txid] = 0

        for tx in self.transactions.values():

            # Skip the genesis transaction
            if tx.txid == '0' or tx.txid == '1':
                continue
            # Add accumulative weight, branch weight, and transaction ID as a label
            label = f"ID: {tx.txid}\nAW: {tx.accumulative_weight}"
            node_labels[tx.txid] = label

            # Determine the color of the node

            if tx in self.tips:
                node_colors[tx.txid] = 'grey'  # grey for tips
                depth_map[tx.txid] = max((depth_map[parent_txid] + 1 for parent_txid in tx.parent_txids), default=0)
                max_depth = max(max_depth, depth_map[tx.txid])
            else:
                node_colors[tx.txid] = 'blue'  # blue for other nodes
                depth_map[tx.txid] = max((depth_map[parent_txid] + 1 for parent_txid in tx.parent_txids), default=0)
                max_depth = max(max_depth, depth_map[tx.txid])

            # Print node colors and IDs
        # for txid, color in node_colors.items():
        #     print(f"Node ID: {txid}, Color: {color}")

        # Get node positions
        pos = {}
        for tx in self.transactions.values():
            depth = depth_map[tx.txid]
            same_depth_txs = [t for t, d in depth_map.items() if d == depth]
            level_size = len(same_depth_txs)
            index_in_level = same_depth_txs.index(tx.txid)
            vertical_position = (index_in_level + 1) / (level_size + 1)  # to make it range between 0 and 1
            pos[tx.txid] = (depth, vertical_position)

        # Convert node_colors to list maintaining the order of transactions
        node_colors_list = [node_colors[tx.txid] for tx in self.transactions.values()]

        # Add edges to the graph and set their colors
        edge_colors = []
        for tx in self.transactions.values():
            for parent_txid in tx.parent_txids:
                G.add_edge(tx.txid, parent_txid)
                # G.add_edge(parent_txid, tx.txid)
                edge_colors.append('grey' if parent_txid == '0' else 'blue')

        # Draw the graph
        plt.figure(figsize=(10, 5))
        # get set of transaction IDs in node_colors
        node_colors_keys = set(node_colors.keys())

        # get set of nodes in G
        G_nodes = set(G.nodes)

        # find keys that are in node_colors but not in G
        extra_keys = node_colors_keys - G_nodes

        print(extra_keys)
        print(len(G.nodes))
        print(len(node_colors_list))
        nx.draw(G, pos=pos, node_color=node_colors_list, node_size=1000, node_shape='s', edge_color=edge_colors)
        nx.draw_networkx_labels(G, pos, labels=node_labels, font_size=8)
        plt.title(f'Batch {self.current_batch}')
        plt.ylim(0, 1)  # Make sure all nodes fit in the figure
        plt.xlim(-1, max_depth + 2)
        # plt.savefig(f'Figures/my_plot_{self.current_batch}.png')
        plt.pause(1)
        plt.show(block=True)

          #
    # def draw_network(self):
    #     # Create a new directed graph
    #     graph = nx.DiGraph()
    #
    #     for node in self.nodes:
    #         for i, peer in enumerate(node.peers, start=1):
    #             delay = self.delay_matrix[(node, peer)]
    #             graph.add_edge(node.name, peer.name, weight=delay)
    #             # print(f"Node {node.name} is connected to Node {peer.name} with delay {self.delay_matrix[(node, peer)]:.2f}")
    #             print(f"{node.name}\n  Peer {i}: {peer.name} with delay {delay:.2f}")
    #
    #     # Define positions using spring_layout
    #     pos = nx.spring_layout(graph, weight="weight",  k=3.0)
    #
    #
    #     # Load the image
    #     laptop_img = mpimg.imread('../Images/lptp.png')
    #
    #     # Draw the nodes
    #     fig, ax = plt.subplots(figsize=(15,15))
    #
    #     for node in graph.nodes:
    #         plt.imshow(laptop_img,
    #                    extent=(pos[node][0] - 0.08, pos[node][0] + 0.08, pos[node][1] - 0.08, pos[node][1] + 0.08))
    #
    #     # # Draw the nodes
    #     # nx.draw_networkx_nodes(graph, pos, node_color="blue", node_size=500)
    #
    #     # Draw the node labels
    #     nx.draw_networkx_labels(graph, pos)
    #
    #     # Draw the edges
    #     nx.draw_networkx_edges(graph, pos)
    #
    #     # Draw the edge labels (delay values)
    #     edge_labels = {(u, v): f"{graph[u][v]['weight']:.2f}" for u, v in graph.edges()}
    #     #nx.draw_networkx_edge_labels(graph, pos, edge_labels=edge_labels)
    #
    #     # Set equal aspect ratio
    #     plt.axis('equal')
    #
    #     # Remove axis ticks and labels
    #     plt.xticks([])
    #     plt.yticks([])
    #
    #     # Display the plot
    #     plt.show(block=True)

    # def draw_network(self):
    #     # Create a new directed graph
    #     graph = nx.DiGraph()
    #
    #     for node in self.nodes:
    #         for i, peer in enumerate(node.peers, start=1):
    #             delay = self.delay_matrix[(node, peer)]
    #             graph.add_edge(node.name, peer.name, weight=delay)
    #             print(f"{node.name}\n  Peer {i}: {peer.name} with delay {delay:.2f}")
    #
    #     # Prepare delay_matrix as numpy array
    #     distances = np.zeros((len(self.nodes), len(self.nodes)))
    #     for i, node1 in enumerate(self.nodes):
    #         for j, node2 in enumerate(self.nodes):
    #             if node1 != node2:
    #                 distances[i, j] = self.delay_matrix[(node1, node2)]
    #
    #     # Calculate MDS
    #     model = MDS(n_components=2, dissimilarity='precomputed', random_state=1)
    #     pos_arr = model.fit_transform(distances)
    #     pos = {node.name: pos_arr[i] for i, node in enumerate(self.nodes)}
    #
    #     # Load the image
    #     laptop_img = mpimg.imread('../Images/lptp.png')
    #
    #     # Draw the nodes
    #     fig, ax = plt.subplots(figsize=(15, 15))
    #
    #     for node_name in graph.nodes:
    #         plt.imshow(laptop_img,
    #                    extent=(pos[node_name][0] - 0.08, pos[node_name][0] + 0.08, pos[node_name][1] - 0.08,
    #                            pos[node_name][1] + 0.08))
    #
    #     # Draw the node labels
    #     nx.draw_networkx_labels(graph, pos)
    #
    #     # Draw the edges
    #     nx.draw_networkx_edges(graph, pos)
    #
    #     # Draw the edge labels (delay values)
    #     edge_labels = {(u, v): f"{graph[u][v]['weight']:.2f}" for u, v in graph.edges()}
    #
    #     # Set equal aspect ratio
    #     plt.axis('equal')
    #
    #     # Remove axis ticks and labels
    #     plt.xticks([])
    #     plt.yticks([])
    #
    #     # Display the plot
    #     plt.show(block=True)



    --------------------------------------------------------------

        #self.env.process(self.coordinator_event(self.env))  # Add the event as a process

    # def coordinator_event(self, env):
    #     while True:
    #         self.coordinator_genesis_milestone()  # Event function
    #         yield env.timeout(self.milestones_interval)  # Delay until the next event
    #
    # def run(self, until_time):
    #     self.env.run(until=until_time)  # Run the simulation

    # def coordinator_genesis_milestone(self):
    #     # Generate a random data string
    #     data = os.urandom(500000)  # generates 500,000 bytes = 0.5 MB
    #     data = data.decode('latin1')  # decode bytes to string using 'latin1' encoding
    #
    #     # Create the genesis transaction with no parent transactions and with data
    #     genesis_milestone = Transaction("0", [], None, data)
    #
    #     # Sign the transaction's data using the Coordinator's private key
    #     genesis_milestone.signature = rsa.sign(
    #         genesis_milestone.get_data_to_sign(),
    #         self.coordinator.private_key,
    #         'SHA-256'
    #     )
    #
    #     # Use Coordinator's method to broadcast the milestone to all peers
    #     self.coordinator.broadcast_milestone(genesis_milestone)
    #
    #     # Add the genesis milestone to the transactions of DAG_Event
    #     self.transactions[genesis_milestone.txid] = genesis_milestone
    #
    #     # Process and visualize transaction for each node
    #     # Process and visualize transaction for each node
    #     for node in self.network.nodes:
    #         if node != self.coordinator:
    #             delay = self.network.delay_matrix[(self.coordinator, node)]
    #             print(f"Transaction received by {node.name} from {self.coordinator.name} with delay: {delay} seconds")
    #             plt.figure(node.name)  # Create a new figure with the name of the node
    #             self.update_and_draw_graphs(node)
    #             plt.pause(delay)  # Show the graph here after each update and delay, then pause for the delay

    -----------------------------
     # def broadcast_milestone(self, milestone):
    #     valid_count = 0
    #     # Send the milestone to all peers in the network
    #     for peer in self.peers:
    #         #print("Peers of Coordinator", pe)
    #         if peer.receive_milestone(milestone):
    #             valid_count += 1
    #     # Log the broadcasted milestone
    #     if isinstance(milestone, Transaction):  # If milestone is a Transaction object
    #         print(
    #             f"Genesis milestone (ID: {milestone.txid}) has been broadcasted by coordinator to all peers and validated by {valid_count} out of {len(self.peers)} peers.")
    #     elif isinstance(milestone, dict):  # If milestone is a dictionary
    #         print(
    #             f"Milestone {milestone['index']} has been broadcasted by coordinator to all peers and validated by {valid_count} out of {len(self.peers)} peers.")

    -----------------------------
        # def receive_milestone(self, milestone):
    #     # Add the received milestone to the coordinator's list of milestones
    #     self.milestones.append(milestone)
    #     # Validate the signature of the milestone
    #     if self.validate_milestone_signature(milestone):
    #         print(f"Milestone {milestone['index']} received and signature validated.")
    #     else:
    #         print(f"Milestone {milestone['index']} received but signature validation failed.")
    #
    # def validate_milestone_signature(self, milestone):
    #     # Verify the signature of the milestone using the coordinator's public key
    #     milestone_data = f"{milestone['index']}{self.name}".encode()
    #     try:
    #         rsa.verify(milestone_data, milestone['signature'], self.coordinator_public_key)
    #         return True
    #     except rsa.VerificationError:
    #         return False
---------------------------------------------------------------
    def draw_dag_event(self):
        # Create a directed graph object
        G = nx.DiGraph()

        # Node colors and labels
        node_colors = {}
        node_labels = {}
        depth_map = {}
        max_depth = 0

        for tx in self.transactions.values():
            # Add transaction ID as a label
            label = f"ID: {tx.txid}"
            node_labels[tx.txid] = label

            # Determine the color of the node
            if tx.txid == "1":  # assuming you have an `is_genesis` property
                node_colors[tx.txid] = 'orange'  # Orange for genesis transaction
                depth_map[tx.txid] = 0
            elif tx in self.tips:
                node_colors[tx.txid] = 'grey'  # Grey for tips
                depth_map[tx.txid] = max((depth_map[parent_txid] + 1 for parent_txid in tx.parent_txids), default=0)
                max_depth = max(max_depth, depth_map[tx.txid])
            else:
                node_colors[tx.txid] = 'blue'  # Blue for other nodes
                node_colors[tx.txid] = 'blue'  # blue for other nodes
                depth_map[tx.txid] = max((depth_map[parent_txid] + 1 for parent_txid in tx.parent_txids), default=0)
                max_depth = max(max_depth, depth_map[tx.txid])

            # # Add edges to the graph
            # for parent_txid in tx.parent_txids:
            #     G.add_edge(parent_txid, tx.txid)  # parent -> child direction
        pos = {}
        for tx in self.transactions.values():
            depth = depth_map[tx.txid]
            same_depth_txs = [t for t, d in depth_map.items() if d == depth]
            level_size = len(same_depth_txs)
            index_in_level = same_depth_txs.index(tx.txid)
            vertical_position = (index_in_level + 1) / (level_size + 1)  # to make it range between 0 and 1
            pos[tx.txid] = (depth, vertical_position)

        # Convert node_colors to list maintaining the order of transactions
        node_colors_list = [node_colors[tx.txid] for tx in self.transactions.values()]

        edge_colors = []
        for tx in self.transactions.values():
            for parent_txid in tx.parent_txids:
                G.add_edge(tx.txid, parent_txid)
                # G.add_edge(parent_txid, tx.txid)
                edge_colors.append('grey' if parent_txid == '0' else 'blue')

        # Draw the graph
        plt.figure(figsize=(10, 5))
        #pos = nx.spring_layout(G)
        nx.draw(G, pos=pos, node_color=node_colors_list, node_size=1000, node_shape='s', edge_color=edge_colors)
        nx.draw_networkx_labels(G, pos, labels=node_labels, font_size=8)
        # nx.draw(G, pos, node_color=node_colors_list, labels=node_labels, with_labels=True)
        plt.title('Transaction DAG')
        plt.show(block=True)

---------------------------------------------------------------------------------------------------------------------
import simpy
from Transaction.transaction import Transaction
import matplotlib.pyplot as plt
from datetime import datetime
import rsa
import threading
import time
import math
import random
import os
import networkx as nx
import multiprocessing as mp
from Transaction.transaction import Transaction
from Network.node import Node, Coordinator

from RandomWalker.randomwalker import RandomWalker
from Network.node import Node

class DAG_Event:
    def __init__(self, poisson_rate, milestones_interval, network):
        self.poisson_rate = poisson_rate
        self.transactions = {}
        self.tips = []
        self.graph = nx.DiGraph()
        self.coordinator = None
        self.milestones_interval = milestones_interval
        self.env = simpy.Environment()  # Add simpy Environment
        self.network = network  # Network reference
        self.graphs = {node.name: nx.DiGraph() for node in self.network.nodes}
        self.graph_events = []  # List to store data for graph drawing events
        self.timestamp = datetime.now().strftime('%H:%M:%S.%f')[:-3]  # Gives you time up to milliseconds
        self.timestamp += str(int(time.time() * 1e9))[-6:]  # Append the last six digits of the current nanosecond time
        self.print_lock = threading.Lock()
        self.graphs_lock = threading.Lock()
        self.transaction_lock = threading.Lock()

    def coordinator_genesis_milestone(self):
        # Generate a random data string
        data = os.urandom(500000)  # generates 500,000 bytes = 0.5 MB
        data = data.decode('latin1')  # decode bytes to string using 'latin1' encoding
        # Create the genesis transaction with no parent transactions and with data
        genesis_milestone = Transaction("0", [], None, data)
        # Sign the transaction's data using the Coordinator's private key
        genesis_milestone.signature = rsa.sign(
            genesis_milestone.get_data_to_sign(),
            self.coordinator.private_key,
            'SHA-256'
        )
        # Use Coordinator's method to broadcast the milestone to all peers
        start_time = datetime.now()
        self.tips.append(genesis_milestone)
        self.coordinator.broadcast_milestone(genesis_milestone)
        # Add the genesis milestone to the transactions of DAG_Event
        self.transactions[genesis_milestone.txid] = genesis_milestone

        # # Process and visualize transaction for each node
        # for node in self.network.nodes:
        #     if node != self.coordinator:
        #         delay = self.network.delay_matrix[(self.coordinator, node)]
        #         self.env.process(self.process_node(node, delay))

        threads = []
        for node in self.network.nodes:
            if node != self.coordinator:
                delay = self.network.delay_matrix[(self.coordinator, node)]
                thread = threading.Thread(target=self.process_node, args=(node, delay))
                threads.append(thread)
                thread.start()

        for thread in threads:
            thread.join()

        end_time = datetime.now()
        total_time = end_time - start_time
        print(f"Total time taken by Coordinator to broadcast to all its peers: {total_time.seconds} seconds, {total_time.microseconds} microseconds")
        # # Update and draw graphs for each node after broadcasting the genesis transaction
        # for node in self.network.nodes:
        #     self.update_and_draw_graphs(node)

    def process_node(self, node, delay):
        time.sleep(delay)
        with self.print_lock:  # assuming print_lock is a threading.Lock() object
            print(f"Transaction received by {node.name} from {self.coordinator.name} with delay: {delay} seconds")
            print("Number of transactions for node", node.name, ":", len(node.nodes_received_transactions))
        # with self.graphs_lock:  # graphs_lock is a threading.Lock() object
        #     plt.figure(node.name)
        #     self.update_and_draw_graphs(node)
        #     plt.savefig(f'plot_node_{node.name}.png')
        #     plt.close()

    def add_transaction(self, node):
        start_time = datetime.now().strftime('%H:%M:%S.%f')[:-3]  # Gives you time up to milliseconds
        start_time += str(int(time.time() * 1e9))[-6:]  # Append the last six digits of the current nanosecond time

        txid = str(len(self.transactions))
        tips= node.tips
        print("Available tips", tips)
        parent_txids = [parent.txid for parent in tips if not parent.children]
        print("Parent transactions", parent_txids)
        if parent_txids:
            tx = node.create_and_sign_transaction_event(txid, parent_txids)
            # Update the DAG and parent transactions
            tx.parent_transactions = [self.transactions[parent_id] for parent_id in parent_txids]
            self.transactions[txid] = tx
            if len(parent_txids) == 1:
                self.graph.add_edge(parent_txids[0], txid)
            elif len(parent_txids) >= 2:
                self.graph.add_edge(parent_txids[0], txid)
                self.graph.add_edge(parent_txids[1], txid)
            print(f"Added {tx} to DAG.")
            print("Node Started Broadcasting the Transcation to All of its Peers")
            node.broadcast_transaction_event(tx)
            for peer in node.peers:
                if peer != node and tx not in peer.transaction_list:  # condition to prevent duplicate processing
                    peer.receive_transaction_event()
                    print(f" Transaction of {node.name} has been broadcasted to all of its network")
            end_time = datetime.now().strftime('%H:%M:%S.%f')[:-3]  # Gives you time up to milliseconds
            end_time += str(int(time.time() * 1e9))[-6:]  # Append the last six digits of the current nanosecond time
            print(f"Start time for transaction and broadcasting: {start_time}")
            print(f"End time for transaction and broadcasting: {end_time}")

            for parent_tx in tx.parent_transactions:
                if parent_tx in self.tips:
                    self.tips.remove(parent_tx)

                # Then add the new transaction to the tips
            self.tips.append(tx)
            return tx
        else:
            print("No tips available for transaction.")
            return None

    # def simulate(self, simulation_time, network):
    #     self.simulation_time = simulation_time
    #
    #     # Create a Manager object to manage shared state
    #     manager = mp.Manager()
    #
    #     # Use the Manager's list to keep track of transactions
    #     transactions = manager.list()
    #
    #     # Create a process for each node
    #     processes = []
    #     for node in network.nodes:
    #         p = mp.Process(target=self.run_node, args=(node, simulation_time, transactions))
    #         processes.append(p)
    #         p.start()
    #
    #     # Wait for all processes to finish
    #     for p in processes:
    #         p.join()
    #
    #     # Update branch weights for all transactions
    #     for tx in self.transactions.values():
    #         tx.update_branch_weight()
    #
    #     # Print updated accumulative weights
    #     self.print_weights()
    #     # self.draw()
    #
    #     return list(transactions)  # convert back to regular list

    def simulate(self, simulation_time, network):
        self.simulation_time = simulation_time

        # Use the list to keep track of transactions
        transactions = []

        # Run each node sequentially
        # for node in network.nodes:
        #     self.run_node(node, simulation_time, transactions)
        # Randomly select one node from the network
        # Create a list of nodes excluding the coordinator
        nodes_without_coordinator = [node for node in network.nodes if not isinstance(node, Coordinator)]
        for node in nodes_without_coordinator:
            self.run_node(node, simulation_time, transactions)
        # # Choose a random node from the list that excludes the coordinator
        # node_to_run = random.choice(nodes_without_coordinator)
        #
        # # Call the run_node method for the selected node
        # self.run_node(node_to_run, simulation_time, transactions)

        # # Update accumulative weights
        # for tx in transactions:
        # self.update_weights_topological_order()
        # # Update branch weights
        # for tx in transactions:
        #     tx.update_branch_weight()
        # # Print updated accumulative weights
        # self.print_weights()
        # # self.draw()
        # self.draw_dag_event()
        # for node in network.nodes:
        #     self.draw_dag_event(node)

        return transactions  # return as regular list

    def run_node(self, node, simulation_time, transactions):
        start_time = datetime.now().strftime('%H:%M:%S.%f')[:-3]  # Gives you time up to milliseconds
        start_time += str(int(time.time() * 1e9))[-6:]  # Append the last six digits of the current nanosecond time
        # Calculate the number of transactions this node will generate
        num_transactions = math.ceil(random.expovariate(self.poisson_rate) * simulation_time)
        #num_transactions =2
        for _ in range(num_transactions):
            tx = self.add_transaction(node)
            if tx is not None:
                transactions.append(tx)
            # Print all transactions including the genesis transaction
            # Print all transactions including the genesis transaction
        all_transactions = self.transactions.keys()
        print("All transaction in the network", all_transactions)
        end_time = datetime.now().strftime('%H:%M:%S.%f')[:-3]  # Gives you time up to milliseconds
        end_time += str(int(time.time() * 1e9))[-6:]  # Append the last six digits of the current nanosecond time
        print(f"Start time for node {node.name} to run transactions: {start_time}")
        print(f"End time for node {node.name} to run transactions: {end_time}")

    def update_weights_topological_order(self):
        # Get a topological order of the transactions
        order = list(nx.topological_sort(self.graph))

        # Print the order
        print("Topological order of transactions:", order)

        # Update the weights in this order
        for txid in order:
            tx = self.transactions[txid]
            tx.update_accumulative_weight()

    def print_weights(self):
        print("\nUpdated accumulative weights and branch weights:")
        for txid, tx in self.transactions.items():
            print(
                f"Transaction {txid}: Accumulative weight = {tx.accumulative_weight}, Branch weight = {tx.branch_weight}")
        print("\n")
    def update_and_draw_graphs(self, node):
        self.graphs[node.name].clear()
        color_map = ['blue'] * len(self.graphs[node.name].nodes)
        labels = {}

        with self.transaction_lock:  # assuming transaction_lock is a threading.Lock() object
            if node.name == "Coordinator":
                node.nodes_received_transactions.append(self.genesis_milestone())

            for transaction in node.nodes_received_transactions:
                self.graphs[node.name].add_node(transaction.txid)
                for parent_txid in transaction.parent_txids:
                    self.graphs[node.name].add_edge(parent_txid, transaction.txid)

                if transaction.txid == "0":
                    color_map.append('orange')
                    labels[transaction.txid] = 'Gen'
                else:
                    color_map.append('blue')
                    labels[transaction.txid] = transaction.txid

        plt.title(f'Node {node.name} DAG view')
        nx.draw(self.graphs[node.name], node_color=color_map, labels=labels, with_labels=True, node_size=1000,
                node_shape='s')

        with self.print_lock:
            print("Number of transactions for node", node.name, ":", len(node.nodes_received_transactions))

    def draw_dag_event(self, node=None):
        # Create a directed graph object
        G = nx.DiGraph()

        # Node colors and labels
        node_colors = {}
        node_labels = {}
        depth_map = {}
        max_depth = 0

        transactions_to_draw = self.transactions.values() if node is None else node.transaction_list  # Change Node to node

        for tx in self.transactions.values():
            # Add transaction ID as a label
            label = f"ID: {tx.txid}"
            node_labels[tx.txid] = label

            # Determine the color of the node
            if tx.txid == "1":  # assuming you have an `is_genesis` property
                node_colors[tx.txid] = 'orange'  # Orange for genesis transaction
                depth_map[tx.txid] = 0
            elif tx in self.tips:
                node_colors[tx.txid] = 'grey'  # Grey for tips
                depth_map[tx.txid] = max((depth_map[parent_txid] + 1 for parent_txid in tx.parent_txids), default=0)
                max_depth = max(max_depth, depth_map[tx.txid])
            else:
                node_colors[tx.txid] = 'blue'  # Blue for other nodes
                node_colors[tx.txid] = 'blue'  # blue for other nodes
                depth_map[tx.txid] = max((depth_map[parent_txid] + 1 for parent_txid in tx.parent_txids), default=0)
                max_depth = max(max_depth, depth_map[tx.txid])

            # # Add edges to the graph
            # for parent_txid in tx.parent_txids:
            #     G.add_edge(parent_txid, tx.txid)  # parent -> child direction
        pos = {}
        for tx in self.transactions.values():
            depth = depth_map[tx.txid]
            same_depth_txs = [t for t, d in depth_map.items() if d == depth]
            level_size = len(same_depth_txs)
            index_in_level = same_depth_txs.index(tx.txid)
            vertical_position = (index_in_level + 1) / (level_size + 1)  # to make it range between 0 and 1
            pos[tx.txid] = (depth, vertical_position)

        # Convert node_colors to list maintaining the order of transactions
        node_colors_list = [node_colors[tx.txid] for tx in self.transactions.values()]

        edge_colors = []
        for tx in self.transactions.values():
            for parent_txid in tx.parent_txids:
                G.add_edge(tx.txid, parent_txid)
                # G.add_edge(parent_txid, tx.txid)
                edge_colors.append('grey' if parent_txid == '0' else 'blue')

        # Draw the graph
        plt.figure(figsize=(10, 5))
        #pos = nx.spring_layout(G)
        if node is None:
            plt.title('Whole DAG graph')
        else:
            plt.title(f'{node.name} graph')
        nx.draw(G, pos=pos, node_color=node_colors_list, node_size=1000, node_shape='s', edge_color=edge_colors)
        nx.draw_networkx_labels(G, pos, labels=node_labels, font_size=8)
        # nx.draw(G, pos, node_color=node_colors_list, labels=node_labels, with_labels=True)
        # plt.title('Transaction DAG')
        plt.show(block=True)







