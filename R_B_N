
    async def broadcast_transaction(self, transaction, sender=None):
        if transaction.txid in self.seen_and_broadcasted_transactions:
            return
        tasks = []
        for peer in self.peers:
            if peer == sender:
                continue
            delay = self.network.delay_matrix[(self, peer)]
            tasks.append(asyncio.create_task(self._send_transaction_to_peer(transaction, peer, delay)))
        await asyncio.gather(*tasks)

    async def _send_transaction_to_peer(self, transaction, peer, delay):
        # await asyncio.sleep(delay)
        await peer.receive_transaction(transaction, self)

    async def receive_transaction(self, transaction, sender=None):
        # Check if the transaction has already been received
        if transaction.txid in self.seen_and_broadcasted_transactions:
            return
        if transaction in self.nodes_received_transactions:
            return
        if transaction in self.transaction_list:
            return
        # Add the transaction to the list of unconfirmed transactions
        self.unconfirmed_transactions.append(transaction)

        # The delay logic  with time.sleep could be replaced with await asyncio.sleep(delay) if want to reintroduce it

        # # Validate the transaction
        # if not transaction.validate_transaction(DIFFICULTY=1):
        #     print(f"Invalid transaction {transaction.txid}")
        #     return
        nodes_received_transactions_ids_b = [tx.txid for tx in self.nodes_received_transactions]
        print(f"{self.name} recived transaction before appending the new transaction {nodes_received_transactions_ids_b}")
        async with self.lock:
            self.nodes_received_transactions.append(transaction)
            nodes_received_transactions_ids= [tx.txid for tx in self.nodes_received_transactions]
            print("TOTAL Recived TRASACTIONS SO  FAR BY NODE", self.name, nodes_received_transactions_ids)
            self.logger.info(f"TOTAL RECIEVED TRASACTIONS SO FAR BY  NOD {self.name} are {len(self.nodes_received_transactions)}")
        # self.transaction_timestamps[transaction.txid] = datetime.now()
        print(
            f"{datetime.now().strftime('%H:%M:%S.%f')} - {self.name} received Transaction ID {transaction.txid} from {sender.name}")
        self.logger.info(
            f"{datetime.now().strftime('%H:%M:%S.%f')} - {self.name} received Transaction ID {transaction.txid} from {sender.name}")

        # If the transaction has no children, add it to the tips and if its a parent then remove it from tip list
        if not transaction.children and transaction not in self.tips:
            print(
                f" Transaction ID : {transaction.txid} do not have children, that's why added to tip of {self.name}")
            self.logger.info(
                f"{datetime.now().strftime('%H:%M:%S.%f')} - Transaction ID : {transaction.txid} do not have children, that's why added to tip of {self.name} ")
            self.tips.append(transaction)
        for parent in transaction.parent_transactions:
            if parent in self.tips:
                self.tips.remove(parent)
                print(f" Transaction {parent.txid} is no longer a tip for {self.name}")
                self.logger.info(
                    f"{datetime.now().strftime('%H:%M:%S.%f')} - Transaction {parent.txid} is no longer a tip for {self.name} ")

        ip_ids = list(set([tip.txid for tip in self.tips]))
        print(f"Tips of {self.name}, {ip_ids}")
        self.logger.info(f"{datetime.now().strftime('%H:%M:%S.%f')} - Tips of {self.name}, {ip_ids} ")

        # Forward the transaction
        self.seen_and_broadcasted_transactions.add(transaction.txid)

        # Forward the transaction to the peers of this node
        await self.broadcast_transaction(transaction, sender)
